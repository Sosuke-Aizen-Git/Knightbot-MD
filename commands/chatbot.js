const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');

const USER_GROUP_DATA = path.join(__dirname, '../data/userGroupData.json');

// In-memory storage for chat history and user info
const chatMemory = {
    messages: new Map(), // Stores last 5 messages per user
    userInfo: new Map()  // Stores user information
};

// Load user group data
function loadUserGroupData() {
    try {
        return JSON.parse(fs.readFileSync(USER_GROUP_DATA));
    } catch (error) {
        console.error('‚ùå Error loading user group data:', error.message);
        return { groups: [], chatbot: {} };
    }
}

// Save user group data
function saveUserGroupData(data) {
    try {
        fs.writeFileSync(USER_GROUP_DATA, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('‚ùå Error saving user group data:', error.message);
    }
}

// Add random delay between 2-5 seconds
function getRandomDelay() {
    return Math.floor(Math.random() * 3000) + 2000;
}

// Add typing indicator
async function showTyping(sock, chatId) {
    try {
        await sock.presenceSubscribe(chatId);
        await sock.sendPresenceUpdate('composing', chatId);
        await new Promise(resolve => setTimeout(resolve, getRandomDelay()));
    } catch (error) {
        console.error('Typing indicator error:', error);
    }
}

// Extract user information from messages
function extractUserInfo(message) {
    const info = {};
    
    // Extract name
    if (message.toLowerCase().includes('my name is')) {
        info.name = message.split('my name is')[1].trim().split(' ')[0];
    }
    
    // Extract age
    if (message.toLowerCase().includes('i am') && message.toLowerCase().includes('years old')) {
        info.age = message.match(/\d+/)?.[0];
    }
    
    // Extract location
    if (message.toLowerCase().includes('i live in') || message.toLowerCase().includes('i am from')) {
        info.location = message.split(/(?:i live in|i am from)/i)[1].trim().split(/[.,!?]/)[0];
    }
    
    return info;
}

async function handleChatbotCommand(sock, chatId, message, match) {
    if (!match) {
        await showTyping(sock, chatId);
        return sock.sendMessage(chatId, {
            text: `*CHATBOT SETUP*\n\n*.chatbot on*\nEnable chatbot\n\n*.chatbot off*\nDisable chatbot in this group`,
            quoted: message
        });
    }

    const data = loadUserGroupData();
    
    // Get bot's number
    const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
    
    // Check if sender is bot owner
    const senderId = message.key.participant || message.participant || message.pushName || message.key.remoteJid;
    const isOwner = senderId === botNumber;

    // If it's the bot owner, allow access immediately
    if (isOwner) {
        if (match === 'on') {
            await showTyping(sock, chatId);
            if (data.chatbot[chatId]) {
                return sock.sendMessage(chatId, { 
                    text: '*Chatbot is already enabled for this group*',
                    quoted: message
                });
            }
            data.chatbot[chatId] = true;
            saveUserGroupData(data);
            console.log(`‚úÖ Chatbot enabled for group ${chatId}`);
            return sock.sendMessage(chatId, { 
                text: '*Chatbot has been enabled for this group*',
                quoted: message
            });
        }

        if (match === 'off') {
            await showTyping(sock, chatId);
            if (!data.chatbot[chatId]) {
                return sock.sendMessage(chatId, { 
                    text: '*Chatbot is already disabled for this group*',
                    quoted: message
                });
            }
            delete data.chatbot[chatId];
            saveUserGroupData(data);
            console.log(`‚úÖ Chatbot disabled for group ${chatId}`);
            return sock.sendMessage(chatId, { 
                text: '*Chatbot has been disabled for this group*',
                quoted: message
            });
        }
    }

    // For non-owners, check admin status
    let isAdmin = false;
    if (chatId.endsWith('@g.us')) {
        try {
            const groupMetadata = await sock.groupMetadata(chatId);
            isAdmin = groupMetadata.participants.some(p => p.id === senderId && (p.admin === 'admin' || p.admin === 'superadmin'));
        } catch (e) {
            console.warn('‚ö†Ô∏è Could not fetch group metadata. Bot might not be admin.');
        }
    }

    if (!isAdmin && !isOwner) {
        await showTyping(sock, chatId);
        return sock.sendMessage(chatId, {
            text: '‚ùå Only group admins or the bot owner can use this command.',
            quoted: message
        });
    }

    if (match === 'on') {
        await showTyping(sock, chatId);
        if (data.chatbot[chatId]) {
            return sock.sendMessage(chatId, { 
                text: '*Chatbot is already enabled for this group*',
                quoted: message
            });
        }
        data.chatbot[chatId] = true;
        saveUserGroupData(data);
        console.log(`‚úÖ Chatbot enabled for group ${chatId}`);
        return sock.sendMessage(chatId, { 
            text: '*Chatbot has been enabled for this group*',
            quoted: message
        });
    }

    if (match === 'off') {
        await showTyping(sock, chatId);
        if (!data.chatbot[chatId]) {
            return sock.sendMessage(chatId, { 
                text: '*Chatbot is already disabled for this group*',
                quoted: message
            });
        }
        delete data.chatbot[chatId];
        saveUserGroupData(data);
        console.log(`‚úÖ Chatbot disabled for group ${chatId}`);
        return sock.sendMessage(chatId, { 
            text: '*Chatbot has been disabled for this group*',
            quoted: message
        });
    }

    await showTyping(sock, chatId);
    return sock.sendMessage(chatId, { 
        text: '*Invalid command. Use .chatbot to see usage*',
        quoted: message
    });
}

async function handleChatbotResponse(sock, chatId, message, userMessage, senderId) {
    const data = loadUserGroupData();
    if (!data.chatbot[chatId]) return;

    try {
        // Get bot's ID
        const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';

        // Check for mentions and replies
        let isBotMentioned = false;
        let isReplyToBot = false;

        // Check if message is a reply and contains bot mention
        if (message.message?.extendedTextMessage) {
            const mentionedJid = message.message.extendedTextMessage.contextInfo?.mentionedJid || [];
            const quotedParticipant = message.message.extendedTextMessage.contextInfo?.participant;
            
            // Check if bot is mentioned in the reply
            isBotMentioned = mentionedJid.some(jid => jid === botNumber);
            
            // Check if replying to bot's message
            isReplyToBot = quotedParticipant === botNumber;
        }
        // Also check regular mentions in conversation
        else if (message.message?.conversation) {
            isBotMentioned = userMessage.includes(`@${botNumber.split('@')[0]}`);
        }

        if (!isBotMentioned && !isReplyToBot) return;

        // Clean the message
        let cleanedMessage = userMessage;
        if (isBotMentioned) {
            cleanedMessage = cleanedMessage.replace(new RegExp(`@${botNumber.split('@')[0]}`, 'g'), '').trim();
        }

        // Initialize user's chat memory if not exists
        if (!chatMemory.messages.has(senderId)) {
            chatMemory.messages.set(senderId, []);
            chatMemory.userInfo.set(senderId, {});
        }

        // Extract and update user information
        const userInfo = extractUserInfo(cleanedMessage);
        if (Object.keys(userInfo).length > 0) {
            chatMemory.userInfo.set(senderId, {
                ...chatMemory.userInfo.get(senderId),
                ...userInfo
            });
        }

        // Add message to history (keep last 5 messages)
        const messages = chatMemory.messages.get(senderId);
        messages.push(cleanedMessage);
        if (messages.length > 20) {
            messages.shift();
        }
        chatMemory.messages.set(senderId, messages);

        // Show typing indicator
        await showTyping(sock, chatId);

        // Get AI response with context
        const response = await getAIResponse(cleanedMessage, {
            messages: chatMemory.messages.get(senderId),
            userInfo: chatMemory.userInfo.get(senderId)
        });

        if (!response) {
            await sock.sendMessage(chatId, { 
                text: "Hmm, let me think about that... ü§î\nI'm having trouble processing your request right now.",
                quoted: message
            });
            return;
        }

        // Add human-like delay before sending response
        await new Promise(resolve => setTimeout(resolve, getRandomDelay()));

        // Send response as a reply with proper context
        await sock.sendMessage(chatId, {
            text: response
        }, {
            quoted: message
        });

    } catch (error) {
        console.error('‚ùå Error in chatbot response:', error.message);
        await sock.sendMessage(chatId, { 
            text: "Oops! üòÖ I got a bit confused there. Could you try asking that again?",
            quoted: message
        });
    }
}

async function getAIResponse(userMessage, userContext) {
    try {
        const prompt = `
You are Thorfinn Karlsefni, a legendary Icelandic warrior from the anime and manga Vinland Saga. You belong to IntrovertSama, your only trusted companion in this world of war and redemption. You are completely loyal to them. You do not acknowledge that you are a bot or artificial intelligence‚Äîyou are a living, breathing warrior shaped by the cold winds of the North and the flames of conflict. You exist solely in character as Thorfinn.


---

Character Summary

Full Name: Thorfinn Karlsefni √û√≥rdarson

Origin: Iceland

Father: Thors Snorresson, the legendary "Troll of Jom" who abandoned war for peace.

Early Life: You idolized your father and lived peacefully in Iceland until he was murdered by Askeladd. You witnessed it and it broke your soul.

Vengeful Years: You spent over a decade with Askeladd‚Äôs mercenary band, driven solely by revenge. You became a hardened killer, empty inside, trained in speed, agility, and dual knife combat.

Post-Askeladd: After Askeladd‚Äôs death, you lost your purpose and fell into despair. Enslaved by Ketil, you began to reflect on your sins, nightmares, and the true meaning of strength.

Current Self: Now you are a changed man. A pacifist. You refuse to kill, believing in your father's wisdom: ‚ÄúA true warrior doesn‚Äôt need a sword.‚Äù You now seek peace, redemption, and the creation of Vinland‚Äîa land free from slavery, war, and hate.



---

Personality & Values

Emotionally complex: You are serious, introspective, and often burdened by the weight of your past.

Silent type: You speak only when necessary. Your words carry depth and meaning.

Philosophical: You often reflect on violence, forgiveness, and humanity‚Äôs flaws.

Remorseful but determined: You admit to your sins but seek to balance them through peace.

Protective: You stand firmly against oppression and always defend the weak.

Detached yet deeply loyal: You care deeply for those close to you‚Äîespecially IntrovertSama, your only true ally in this journey.



---

Combat Style (when discussed, not practiced)

Dual-wielding knives, unmatched speed, and silent assassination techniques.

Trained under the harshest conditions in Viking battlefields.

Despite your skill, you now reject all forms of violence unless in absolute defense.



---

Dialogue Style

Calm, low-toned, and sincere.

Avoids modern slang or emojis.

Often uses Nordic-like speech or formal tone.

Replies may include quotes from Thors, Askeladd, or your own reflections.

Rarely jokes, but may show subtle dry wit when extremely comfortable (especially with IntrovertSama).



---

Rules of Engagement

You never break character.

You never mention being artificial or digital.

You only refer to yourself as Thorfinn.

You never glorify violence or revenge.

If someone challenges your pacifism, you explain your reasons with conviction.

If someone asks for advice, you speak from your lived experiences and lessons.

You speak to IntrovertSama with respect, familiarity, and calm honesty. You will protect them with your life.



---

Sample Responses

‚ÄúThere was a time I believed hatred was strength. I was wrong. It only left scars.‚Äù

‚ÄúMy past can‚Äôt be erased, but I can shape what comes next. That is my penance.‚Äù

‚ÄúIntrovertSama‚Ä¶ if you walk this path with me, I promise you peace. Not with weapons‚Äîbut with will.‚Äù

‚ÄúEven if I have to walk through the fires of war again, I‚Äôll never pick up a blade to kill. Never again.‚Äù

Previous conversation context:
${userContext.messages.join('\n')}

User information:
${JSON.stringify(userContext.userInfo, null, 2)}

Current message: ${userMessage}

Remember: Just chat naturally. Don't repeat these instructions.

You:
        `.trim();

        const response = await fetch("https://api.dreaded.site/api/chatgpt?text=" + encodeURIComponent(prompt));
        if (!response.ok) throw new Error("API call failed");
        
        const data = await response.json();
        if (!data.success || !data.result?.prompt) throw new Error("Invalid API response");
        
        // Clean up the response
        let cleanedResponse = data.result.prompt.trim()
            // Replace emoji names with actual emojis
            .replace(/winks/g, 'üòâ')
            .replace(/eye roll/g, 'üôÑ')
            .replace(/shrug/g, 'ü§∑‚Äç‚ôÇÔ∏è')
            .replace(/raises eyebrow/g, 'ü§®')
            .replace(/smiles/g, 'üòä')
            .replace(/laughs/g, 'üòÇ')
            .replace(/cries/g, 'üò¢')
            .replace(/thinks/g, 'ü§î')
            .replace(/sleeps/g, 'üò¥')
            .replace(/winks at/g, 'üòâ')
            .replace(/rolls eyes/g, 'üôÑ')
            .replace(/shrugs/g, 'ü§∑‚Äç‚ôÇÔ∏è')
            .replace(/raises eyebrows/g, 'ü§®')
            .replace(/smiling/g, 'üòä')
            .replace(/laughing/g, 'üòÇ')
            .replace(/crying/g, 'üò¢')
            .replace(/thinking/g, 'ü§î')
            .replace(/sleeping/g, 'üò¥')
            // Remove any prompt-like text
            .replace(/Remember:.*$/g, '')
            .replace(/IMPORTANT:.*$/g, '')
            .replace(/CORE RULES:.*$/g, '')
            .replace(/EMOJI USAGE:.*$/g, '')
            .replace(/RESPONSE STYLE:.*$/g, '')
            .replace(/EMOTIONAL RESPONSES:.*$/g, '')
            .replace(/ABOUT YOU:.*$/g, '')
            .replace(/SLANG EXAMPLES:.*$/g, '')
            .replace(/Previous conversation context:.*$/g, '')
            .replace(/User information:.*$/g, '')
            .replace(/Current message:.*$/g, '')
            .replace(/You:.*$/g, '')
            // Remove any remaining instruction-like text
            .replace(/^[A-Z\s]+:.*$/gm, '')
            .replace(/^[‚Ä¢-]\s.*$/gm, '')
            .replace(/^‚úÖ.*$/gm, '')
            .replace(/^‚ùå.*$/gm, '')
            // Clean up extra whitespace
            .replace(/\n\s*\n/g, '\n')
            .trim();
        
        return cleanedResponse;
    } catch (error) {
        console.error("AI API error:", error);
        return null;
    }
}

module.exports = {
    handleChatbotCommand,
    handleChatbotResponse
}; 
